diff --git a/GraspPlanner.py b/GraspPlanner.py
index 0559549..0152d39 100644
--- a/GraspPlanner.py
+++ b/GraspPlanner.py
@@ -17,14 +17,16 @@ def MakeGripperFrames(X_WG, t0=0):
     # Set the timing
     times = {"initial": t0}
     X_GinitialGprepick = X_WG["initial"].inverse() @ X_WG["prepick"]
-    times["prepick"] = times["initial"] + 2 * np.linalg.norm(
+    times["prepick"] = times["initial"] + np.linalg.norm(
         X_GinitialGprepick.translation()
     )
-    times["pick_start"] = times["prepick"] + 1.0
-    times["pick_end"] = times["pick_start"] + 1.0
+    times["pick_start"] = times["prepick"] + 0.5
+    # times["pick_end"] = times["pick_start"] + 1.0
+    times["pick_end"] = 2.5
     X_WG["pick_start"] = X_WG["pick"]
     X_WG["pick_end"] = X_WG["pick"]
-    times["postpick"] = times["pick_end"] + 1.0
+    # times["postpick"] = times["pick_end"] + 1.0
+    times["postpick"] = 3
     X_WG["postpick"] = RigidTransform(RotationMatrix.MakeXRotation(-np.pi / 2), [0, 0, 0.7])
     times["end"] = times["postpick"] + 10.0
     X_WG["end"] = X_WG["postpick"]
@@ -111,7 +113,7 @@ class GraspPlanner(LeafSystem):
         times = context.get_abstract_state(int(self._times_index)).get_value()
         if mode == PlannerState.WAIT:
             # Wait for some amount of time for the objects to settle down
-            if context.get_time() - times["initial"] > 1.0:
+            if context.get_time() - times["initial"] > 0.5:
                 self.Plan(context, state)
             return
 
@@ -128,11 +130,10 @@ class GraspPlanner(LeafSystem):
         state.get_mutable_abstract_state(int(self._mode_index)).set_value(
             PlannerState.PICK
         )
-        X_G["place"] = RigidTransform([0.5, 0.5, 0.3])
         X_G, times = MakeGripperFrames(X_G, t0=context.get_time())
-        print(
-            f"Planned {times['postpick'] - times['initial']} s trajectory at time {context.get_time()}"
-        )
+        # print(
+        #     f"Planned {times['postpick'] - times['initial']} s trajectory at time {context.get_time()}"
+        # )
         traj_X_G = MakeGripperPoseTrajectory(X_G, times)
         traj_wsg_command = MakeGripperCommandTrajectory(times)
 
diff --git a/__pycache__/GraspPlanner.cpython-310.pyc b/__pycache__/GraspPlanner.cpython-310.pyc
index c3da0ea..880c059 100644
Binary files a/__pycache__/GraspPlanner.cpython-310.pyc and b/__pycache__/GraspPlanner.cpython-310.pyc differ
diff --git a/__pycache__/drivers.cpython-310.pyc b/__pycache__/drivers.cpython-310.pyc
index a14a521..2fee44d 100644
Binary files a/__pycache__/drivers.cpython-310.pyc and b/__pycache__/drivers.cpython-310.pyc differ
diff --git a/data/one_step_end2end.zip b/data/one_step_end2end.zip
deleted file mode 100644
index 2859bd7..0000000
Binary files a/data/one_step_end2end.zip and /dev/null differ
diff --git a/drivers.py b/drivers.py
index 1644612..be7c67d 100644
--- a/drivers.py
+++ b/drivers.py
@@ -20,7 +20,7 @@ pid_coeffs = {
         "kp": np.array([2000, 1500, 1500, 1500, 1500, 500, 500]),
     },
     "point": {
-        "kp": 100 * np.ones((6, 1)),
+        "kp": 100 * np.ones((6)),
         "limit": 1000,
     },
 }
@@ -30,6 +30,19 @@ pid_coeffs["point"]["kd"] = 2 * np.sqrt(pid_coeffs["point"]["kp"])
 pid_coeffs["point"]["ki"] = 20 * np.ones_like(pid_coeffs["point"]["kp"])
 
 
+class SanityCheck(LeafSystem):
+    def __init__(self, n):
+        super().__init__()
+        self.DeclareVectorInputPort("in", n)
+        self.DeclareVectorOutputPort("out", n, self.CalcOutput)
+
+    def CalcOutput(self, context, output):
+        u = self.get_input_port(0).Eval(context)
+        if not np.all(np.isfinite(u)):
+            raise RuntimeError("Something is not finite")
+        output.SetFromVector(u)
+
+
 class GripperPoseToPosition(LeafSystem):
 
     def __init__(self, X_GB=RigidTransform()):
@@ -100,9 +113,9 @@ class PositionController(Diagram):
             inverse_dynamics.GetInputPort("desired_state"),
         )
         builder.ConnectInput("state", inverse_dynamics.GetInputPort("estimated_state"))
-        builder.ExportOutput(
-            inverse_dynamics.GetOutputPort("generalized_force"), "actuation"
-        )
+        check = builder.AddSystem(SanityCheck(6))
+        builder.Connect(inverse_dynamics.GetOutputPort("generalized_force"), check.get_input_port(0))
+        builder.ExportOutput(check.get_output_port(0), "actuation")
 
         position_pass_through = builder.AddNamedSystem(
             "position_pass_through", PassThrough(num_positions)
diff --git a/envs/__pycache__/one_step_end2end_grasp.cpython-310.pyc b/envs/__pycache__/one_step_end2end_grasp.cpython-310.pyc
index a6103f8..3ff5e94 100644
Binary files a/envs/__pycache__/one_step_end2end_grasp.cpython-310.pyc and b/envs/__pycache__/one_step_end2end_grasp.cpython-310.pyc differ
diff --git a/envs/one_step_end2end_grasp.py b/envs/one_step_end2end_grasp.py
index 368e5bc..27d00c9 100644
--- a/envs/one_step_end2end_grasp.py
+++ b/envs/one_step_end2end_grasp.py
@@ -1,4 +1,6 @@
 from typing import Callable
+import itertools
+import warnings
 
 import gymnasium as gym
 import numpy as np
@@ -11,6 +13,7 @@ from pydrake.geometry import (
     DepthRenderCamera,
     MeshcatVisualizer,
     RenderCameraCore,
+    SourceId
 )
 from pydrake.gym import DrakeGymEnv
 from pydrake.manipulation import SchunkWsgPositionController
@@ -57,7 +60,10 @@ class ActionToSE3(LeafSystem):
 
     def CalcOutput(self, context, output):
         x = self.get_input_port(0).Eval(context)
-        q = x[:4] / np.linalg.norm(x[:4])
+        if np.linalg.norm(x[:4]) >= 0.01:
+            q = x[:4] / np.linalg.norm(x[:4])
+        else:
+            q = np.array([1, 0, 0, 0])
         output.set_value((0, RigidTransform(Quaternion(q), x[4:])))
 
 
@@ -70,8 +76,7 @@ class PointCloudMerger(LeafSystem):
         self.DeclareAbstractInputPort("cloud2", model_point_cloud)
         self._crop_lower = [-0.2, -0.2, 0.05]
         self._crop_upper = [0.2, 0.2, 0.25]
-
-        port = self.DeclareAbstractOutputPort(
+        self.DeclareAbstractOutputPort(
             "cloud", lambda: model_point_cloud, self.CalcOutput
         )
 
@@ -105,7 +110,7 @@ gym_time_step = 0.05
 controller_time_step = 0.01
 gym_time_limit = 5
 drake_contact_models = ["point", "hydroelastic_with_fallback"]
-contact_model = drake_contact_models[1]
+contact_model = drake_contact_models[0]
 drake_contact_approximations = ["sap", "tamsi", "similar", "lagged"]
 contact_approximation = drake_contact_approximations[0]
 
@@ -240,7 +245,7 @@ def setup(meshcat=None, time_limit=5, debug=False, obs_noise=False):
             object_state = self.get_input_port(0).Eval(context)
             gripper_state = self.get_input_port(1).Eval(context)
             cost = np.linalg.norm(object_state[4:7] - gripper_state[:3]) ** 2
-            reward = 10 if time >= 1 and object_state[6] >= 0.3 else 1
+            reward = 100 if time >= 1 and object_state[6] >= 0.3 else 1
             output[0] = reward - cost
 
     reward = builder.AddSystem(RewardSystem())
@@ -278,23 +283,18 @@ def make_sim(meshcat=None, time_limit=5, debug=False, obs_noise=False):
     class ObservationPublisher(LeafSystem):
         def __init__(self, noise=False):
             LeafSystem.__init__(self)
-            self.DeclareAbstractInputPort("image0", AbstractValue.Make(ImageDepth32F()))
             self.DeclareAbstractInputPort("cloud", AbstractValue.Make(PointCloud()))
             self.DeclareVectorOutputPort("observations", cloud_size * 3, self.CalcObs)
             self.noise = noise
 
         def CalcObs(self, context, output):
-            image0 = self.get_input_port(0).Eval(context)
-            cloud = self.get_input_port(1).Eval(context)
+            cloud = self.get_input_port(0).Eval(context)
             cloud.resize(cloud_size)
             output.SetFromVector(np.nan_to_num(cloud.xyzs().reshape(-1)))
 
     obs_pub = builder.AddSystem(ObservationPublisher(noise=obs_noise))
-    builder.Connect(
-        diagram.GetOutputPort("camera0_depth_image"), obs_pub.get_input_port(0)
-    )
-    builder.Connect(merger.get_output_port(0), obs_pub.get_input_port(1))
-    builder.ExportOutput(obs_pub.get_output_port(), "observations")
+    builder.Connect(merger.get_output_port(0), obs_pub.get_input_port(0))
+    builder.ExportOutput(obs_pub.get_output_port(0), "observations")
     builder.ExportOutput(diagram.GetOutputPort("reward"), "reward")
     builder.ExportInput(diagram.GetInputPort("actions"), "actions")
 
@@ -306,25 +306,26 @@ def make_sim(meshcat=None, time_limit=5, debug=False, obs_noise=False):
         plant = diagram.GetSubsystemByName("plant")
         plant_context = plant.GetMyContextFromRoot(context)
 
-        scene_graph = diagram.GetSubsystemByName("scene_graph")
-        scene_graph_context = scene_graph.GetMyContextFromRoot(context)
-        query_object = scene_graph.get_query_output_port().Eval(scene_graph_context)
-        wsg = plant.GetBodyByName("body")
-        floor = plant.GetBodyByName("box")
-        gids_wsg = plant.GetCollisionGeometriesForBody(wsg)
-        gids_floor = plant.GetCollisionGeometriesForBody(floor)
-        for pair in query_object.ComputePointPairPenetration():
-            if (pair.id_A in gids_wsg and pair.id_B in gids_floor) or (
-                pair.id_B in gids_wsg and pair.id_A in gids_floor
-            ):
-                print("Collision between floor and wsg detected!")
-                return EventStatus.ReachedTermination(
-                    diagram, "Collision between floor and wsg detected!"
-                )
-
+        # scene_graph = diagram.GetSubsystemByName("scene_graph")
+        # scene_graph_context = scene_graph.GetMyContextFromRoot(context)
+        # query_object = scene_graph.get_query_output_port().Eval(scene_graph_context)
+        # wsg = [plant.GetBodyByName("body"), plant.GetBodyByName("left_finger"), plant.GetBodyByName("right_finger")]
+        # gids_wsg = list(itertools.chain.from_iterable([plant.GetCollisionGeometriesForBody(x) for x in wsg]))
+        # floor = plant.GetBodyByName("box")
+        # gids_floor = plant.GetCollisionGeometriesForBody(floor)
+        # for pair in query_object.ComputePointPairPenetration():
+        #     if (pair.id_A in gids_wsg and pair.id_B in gids_floor) or (
+        #         pair.id_B in gids_wsg and pair.id_A in gids_floor
+        #     ):
+        #         # print(f"Penetration depth (betwen wsg and floor) = {pair.depth}")
+        #         if pair.depth > 1e-2:
+        #             return EventStatus.ReachedTermination(
+        #                 diagram, "Collision between floor and wsg detected!"
+        #             )
+        
         obj_state = plant.GetOutputPort("004_sugar_box_state").Eval(plant_context)
-        if obj_state[6] < -0.01:
-            print("object falls below 0")
+        if obj_state[6] < -0.025:
+            # print("object falls below 0")
             return EventStatus.ReachedTermination(diagram, "object falls below 0")
         if context.get_time() > time_limit:
             return EventStatus.ReachedTermination(diagram, "time limit")
@@ -335,18 +336,18 @@ def make_sim(meshcat=None, time_limit=5, debug=False, obs_noise=False):
     if debug:
         import pydot
 
-        pydot.graph_from_dot_data(diagram.GetGraphvizString(max_depth=2))[0].write_png(
+        pydot.graph_from_dot_data(final_diagram.GetGraphvizString(max_depth=2))[0].write_png(
             "images/OneStepEnd2EndGrasp-v0-diagram.png"
         )
 
     return simulator
 
 
-def reset_handler(simulator, diagram_context, seed):
+def reset_handler(simulator, context, seed):
     rng = np.random.default_rng(seed)
     diagram = simulator.get_system()
     system = diagram.GetSubsystemByName("system")
-    system_context = diagram.GetMutableSubsystemContext(system, diagram_context)
+    system_context = diagram.GetMutableSubsystemContext(system, context)
     plant = system.GetSubsystemByName("plant")
     plant_context = system.GetMutableSubsystemContext(plant, system_context)
     sphere = plant.GetModelInstanceByName("sphere")
@@ -411,12 +412,26 @@ class OneStepEnd2EndGrasp(DrakeGymEnv):
         context = self.simulator.get_context()
         time = context.get_time()
         self.action_port.FixValue(context, action)
-        if time < 1:
-            status = self.simulator.AdvanceTo(1)
-        else:
-            status = self.simulator.AdvanceTo(time + self.time_step)
-
         truncated = False
+
+        prev_observation = self.observation_port.Eval(context)
+        try:
+            if time < 0.5:
+                status = self.simulator.AdvanceTo(0.5)
+            elif time < 2:
+                status = self.simulator.AdvanceTo(2)
+            else:
+                status = self.simulator.AdvanceTo(3.1)
+        except RuntimeError as e:
+            warnings.warn("Calling Done after catching RuntimeError")
+            warnings.warn(e.args[0])
+            truncated = True
+            terminated = False
+            reward = 0
+            info = dict()
+            
+            return prev_observation, reward, terminated, truncated, info
+
         observation = self.observation_port.Eval(context)
         reward = self.reward(self.simulator.get_system(), context)
         terminated = not truncated and (
@@ -426,16 +441,17 @@ class OneStepEnd2EndGrasp(DrakeGymEnv):
 
         return observation, reward, terminated, truncated, info
 
-    def reset(self, *, seed=None, options=None):
-        context = self.simulator.get_mutable_context()
-        context.SetTime(0)
-        self.simulator.Initialize()
-        self.simulator.get_system().SetDefaultContext(context)
-        self.reset_handler(self.simulator, context, seed)
-        observations = self.observation_port.Eval(context)
-        info = self.info_handler(self.simulator)
+    # def reset(self, *, seed=None, options=None):
+    #     super().reset(seed=seed)
+    #     context = self.simulator.get_mutable_context()
+    #     context.SetTime(0)
+    #     self.simulator.Initialize()
+    #     self.simulator.get_system().SetDefaultContext(context)
+    #     self.reset_handler(self.simulator, context, seed)
+    #     observations = self.observation_port.Eval(context)
+    #     info = self.info_handler(self.simulator)
 
-        return observations, info
+    #     return observations, info
 
 
 gym.envs.register(
@@ -450,8 +466,8 @@ def make_env(meshcat=None, time_limit=gym_time_limit, debug=False, obs_noise=Fal
 
     # Define action space
     action_space = gym.spaces.Box(
-        low=np.asarray([-1, -1, -1, -1, -0.5, -0.5, 0]),
-        high=np.asarray([1, 1, 1, 1, 0.5, 0.5, 0.5]),
+        low=np.asarray([-1, -1, -1, -1, -0.2, -0.2, 0.05]),
+        high=np.asarray([1, 1, 1, 1, 0.2, 0.2, 0.25]),
         dtype=np.float64,
     )
 
diff --git a/images/OneStepEnd2EndGrasp-v0-diagram.png b/images/OneStepEnd2EndGrasp-v0-diagram.png
index 925d830..f1f726d 100644
Binary files a/images/OneStepEnd2EndGrasp-v0-diagram.png and b/images/OneStepEnd2EndGrasp-v0-diagram.png differ
diff --git a/models/floor.sdf b/models/floor.sdf
index bb98ee7..795fd98 100644
--- a/models/floor.sdf
+++ b/models/floor.sdf
@@ -26,43 +26,11 @@
           <diffuse>1 1 1 1</diffuse>
         </material>
       </visual>
-      <collision name="bottom">
+      <collision name="collision">
         <pose>0 0 0 0 0 -0.05</pose>
         <geometry>
           <box>
-            <size>2 2 0.05</size>
-          </box>
-        </geometry>
-      </collision>
-      <collision name="front">
-        <pose>2 0 .15 0 0 0</pose>
-        <geometry>
-          <box>
-            <size>.1 4 0.3</size>
-          </box>
-        </geometry>
-      </collision>
-      <collision name="back">
-        <pose>-2 0 .15 0 0 0</pose>
-        <geometry>
-          <box>
-            <size>.1 4 0.3</size>
-          </box>
-        </geometry>
-      </collision>
-      <collision name="left">
-        <pose>0 2 .15 0 0 0</pose>
-        <geometry>
-          <box>
-            <size>4 .1 0.3</size>
-          </box>
-        </geometry>
-      </collision>
-      <collision name="right">
-        <pose>0 -2 .15 0 0 0</pose>
-        <geometry>
-          <box>
-            <size>4 .1 0.3</size>
+            <size>2 2 0.0505</size>
           </box>
         </geometry>
       </collision>
diff --git a/train_one_step_e2e.py b/train_one_step_e2e.py
index 788ffab..522688e 100644
--- a/train_one_step_e2e.py
+++ b/train_one_step_e2e.py
@@ -29,9 +29,9 @@ def main():
 
     config = {
         "policy_type": "MlpPolicy",
-        "total_timesteps": 5e4 if not args.test else 5,
+        "total_timesteps": 5e5 if not args.test else 5,
         "env_name": "OneStepEnd2EndGrasp-v0",
-        "env_time_limit": 10 if not args.test else 0.5,
+        "env_time_limit": 3 if not args.test else 0.5,
         "observations": "state",
     }
 
@@ -46,10 +46,10 @@ def main():
     else:
         run = wandb.init(mode="disabled")
 
-    zip = "../data/one_step_e2e.zip"
+    zip = "data/one_step_e2e.zip"
 
     # num_cpu = int(cpu_count() / 4)
-    num_cpu = 6
+    num_cpu = 36
     if args.train_single_env:
         meshcat = StartMeshcat()
         env = gym.make(
@@ -100,6 +100,9 @@ def main():
         model = PPO(
             config["policy_type"],
             env,
+            n_steps = 1024,
+            n_epochs=5,
+            batch_size=64,
             verbose=1,
             tensorboard_log=args.log_path or f"runs/{run.id}",
             device="cpu",
@@ -113,7 +116,7 @@ def main():
         model.learn(
             total_timesteps=config["total_timesteps"] if not args.test else 4,
             reset_num_timesteps=new_log,
-            # callback=WandbCallback(),
+            callback=WandbCallback(),
         )
         print("Finish!")
         if args.test:
